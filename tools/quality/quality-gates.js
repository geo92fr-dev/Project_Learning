#!/usr/bin/env node

/**
 * @criticality HIGH
 * @depends package.json, src/, tests/
 * @description Quality Gates automatis√©es avec seuils configurables par phase
 * @phase ALL - Applicable √† toutes les phases
 * @category quality
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

class QualityGates {
    constructor() {
        this.projectRoot = process.cwd();
        this.configPath = path.join(this.projectRoot, 'CONFIG_quality_gates.json');
        this.config = this.loadConfig();
        this.results = [];
    }

    /**
     * Chargement configuration quality gates
     */
    loadConfig() {
        const defaultConfig = {
            "phase-0": {
                "coverage": { "minimum": 70, "target": 80 },
                "complexity": { "max": 5 },
                "security": { "level": "medium" },
                "performance": { "lighthouse": 70 }
            },
            "phase-1": {
                "coverage": { "minimum": 80, "target": 85 },
                "complexity": { "max": 7 },
                "security": { "level": "high" },
                "performance": { "lighthouse": 75 }
            },
            "phase-2": {
                "coverage": { "minimum": 85, "target": 90 },
                "complexity": { "max": 8 },
                "security": { "level": "high" },
                "performance": { "lighthouse": 80 }
            },
            "phase-3": {
                "coverage": { "minimum": 85, "target": 90 },
                "complexity": { "max": 8 },
                "security": { "level": "high" },
                "performance": { "lighthouse": 85 }
            },
            "phase-4": {
                "coverage": { "minimum": 90, "target": 95 },
                "complexity": { "max": 9 },
                "security": { "level": "critical" },
                "performance": { "lighthouse": 90 }
            },
            "phase-5": {
                "coverage": { "minimum": 90, "target": 95 },
                "complexity": { "max": 9 },
                "security": { "level": "critical" },
                "performance": { "lighthouse": 90 }
            },
            "phase-6": {
                "coverage": { "minimum": 95, "target": 98 },
                "complexity": { "max": 10 },
                "security": { "level": "critical" },
                "performance": { "lighthouse": 95 }
            }
        };

        if (fs.existsSync(this.configPath)) {
            try {
                const customConfig = JSON.parse(fs.readFileSync(this.configPath, 'utf8'));
                return { ...defaultConfig, ...customConfig };
            } catch (error) {
                console.warn('‚ö†Ô∏è Erreur lecture config, utilisation valeurs par d√©faut');
                return defaultConfig;
            }
        } else {
            // Cr√©er fichier de config par d√©faut
            fs.writeFileSync(this.configPath, JSON.stringify(defaultConfig, null, 2));
            return defaultConfig;
        }
    }

    /**
     * D√©tection automatique de la phase actuelle
     */
    detectCurrentPhase() {
        try {
            // V√©rifier s'il y a un indicateur de phase dans package.json
            const packageJson = JSON.parse(fs.readFileSync(path.join(this.projectRoot, 'package.json'), 'utf8'));
            if (packageJson.funlearning && packageJson.funlearning.phase) {
                return packageJson.funlearning.phase;
            }

            // D√©tecter bas√© sur la structure des fichiers
            const srcPath = path.join(this.projectRoot, 'src');
            
            if (!fs.existsSync(srcPath)) return 'phase-0';
            
            const hasAuth = fs.existsSync(path.join(srcPath, 'lib', 'firebase')) || 
                           fs.existsSync(path.join(srcPath, 'routes', 'auth'));
            if (!hasAuth) return 'phase-0';
            
            const hasContent = fs.existsSync(path.join(srcPath, 'routes', 'cours')) ||
                              fs.existsSync(path.join(srcPath, 'lib', 'components'));
            if (!hasContent) return 'phase-1';
            
            const hasExercises = fs.existsSync(path.join(srcPath, 'routes', 'exercices')) ||
                                fs.existsSync(path.join(srcPath, 'lib', 'components', 'exercises'));
            if (!hasExercises) return 'phase-2';
            
            const hasPWA = fs.existsSync(path.join(this.projectRoot, 'static', 'manifest.json')) ||
                          fs.existsSync(path.join(srcPath, 'service-worker.ts'));
            if (!hasPWA) return 'phase-3';
            
            const hasAdmin = fs.existsSync(path.join(srcPath, 'routes', 'admin'));
            if (!hasAdmin) return 'phase-4';
            
            return 'phase-5'; // Assume phase avanc√©e si tout est pr√©sent
            
        } catch (error) {
            console.warn('‚ö†Ô∏è Erreur d√©tection phase, utilisation phase-1 par d√©faut');
            return 'phase-1';
        }
    }

    /**
     * Ex√©cution de toutes les quality gates
     */
    async executeAll(phase = null) {
        const currentPhase = phase || this.detectCurrentPhase();
        const phaseConfig = this.config[currentPhase];
        
        console.log(`üéØ Ex√©cution Quality Gates pour ${currentPhase}`);
        console.log(`üìã Seuils: Coverage ${phaseConfig.coverage.minimum}%, Complexity ‚â§${phaseConfig.complexity.max}, Security ${phaseConfig.security.level}`);
        
        let allPassed = true;

        // Gate 1: Couverture de tests
        const coveragePass = await this.gateTestCoverage(phaseConfig.coverage);
        allPassed = allPassed && coveragePass;

        // Gate 2: Complexit√© du code
        const complexityPass = await this.gateCodeComplexity(phaseConfig.complexity);
        allPassed = allPassed && complexityPass;

        // Gate 3: S√©curit√©
        const securityPass = await this.gateSecurity(phaseConfig.security);
        allPassed = allPassed && securityPass;

        // Gate 4: Lint et qualit√© statique
        const lintPass = await this.gateLinting();
        allPassed = allPassed && lintPass;

        // Gate 5: Build
        const buildPass = await this.gateBuild();
        allPassed = allPassed && buildPass;

        // Gate 6: Performance (si applicable)
        if (phaseConfig.performance && ['phase-2', 'phase-3', 'phase-4', 'phase-5', 'phase-6'].includes(currentPhase)) {
            const performancePass = await this.gatePerformance(phaseConfig.performance);
            allPassed = allPassed && performancePass;
        }

        this.generateReport(currentPhase, allPassed);
        
        return allPassed;
    }

    /**
     * Gate 1: Couverture de tests
     */
    async gateTestCoverage(coverageConfig) {
        console.log('üß™ Gate 1: Couverture de tests...');
        
        try {
            const result = execSync('npm run test:coverage --silent', { 
                encoding: 'utf8',
                cwd: this.projectRoot 
            });
            
            // Parser le r√©sultat de couverture (format standard)
            const coverageMatch = result.match(/All files\s+\|\s+(\d+(?:\.\d+)?)/);
            const coverage = coverageMatch ? parseFloat(coverageMatch[1]) : 0;
            
            const passed = coverage >= coverageConfig.minimum;
            const status = passed ? '‚úÖ' : '‚ùå';
            const target = coverage >= coverageConfig.target ? 'üéØ' : '';
            
            console.log(`${status} Couverture: ${coverage}% (min: ${coverageConfig.minimum}%) ${target}`);
            
            this.results.push({
                gate: 'Test Coverage',
                status: passed ? 'PASS' : 'FAIL',
                value: `${coverage}%`,
                threshold: `${coverageConfig.minimum}%`,
                details: passed ? `Couverture suffisante` : `Couverture insuffisante: ${coverage}% < ${coverageConfig.minimum}%`
            });
            
            return passed;
            
        } catch (error) {
            console.log('‚ùå Gate 1: √âchec couverture tests');
            this.results.push({
                gate: 'Test Coverage',
                status: 'ERROR',
                value: 'N/A',
                threshold: `${coverageConfig.minimum}%`,
                details: `Erreur ex√©cution tests: ${error.message}`
            });
            return false;
        }
    }

    /**
     * Gate 2: Complexit√© du code
     */
    async gateCodeComplexity(complexityConfig) {
        console.log('üìä Gate 2: Complexit√© du code...');
        
        try {
            // Utiliser un outil comme eslint avec r√®gles de complexit√©
            const result = execSync('npx eslint src/ --format=json --rule "complexity: [2, ' + complexityConfig.max + ']"', { 
                encoding: 'utf8',
                cwd: this.projectRoot 
            });
            
            const eslintResults = JSON.parse(result || '[]');
            const complexityErrors = eslintResults.reduce((acc, file) => 
                acc + file.messages.filter(msg => msg.ruleId === 'complexity').length, 0);
            
            const passed = complexityErrors === 0;
            const status = passed ? '‚úÖ' : '‚ùå';
            
            console.log(`${status} Complexit√©: ${complexityErrors} violations (max: ${complexityConfig.max})`);
            
            this.results.push({
                gate: 'Code Complexity',
                status: passed ? 'PASS' : 'FAIL',
                value: `${complexityErrors} violations`,
                threshold: `‚â§ ${complexityConfig.max}`,
                details: passed ? 'Complexit√© acceptable' : `${complexityErrors} fonctions trop complexes`
            });
            
            return passed;
            
        } catch (error) {
            // Si ESLint n'est pas configur√© pour la complexit√©, on passe
            console.log('‚ö†Ô∏è Gate 2: Complexit√© non mesurable (ESLint non configur√©)');
            this.results.push({
                gate: 'Code Complexity',
                status: 'SKIP',
                value: 'N/A',
                threshold: `‚â§ ${complexityConfig.max}`,
                details: 'ESLint complexit√© non configur√©'
            });
            return true; // Ne pas bloquer si l'outil n'est pas configur√©
        }
    }

    /**
     * Gate 3: S√©curit√©
     */
    async gateSecurity(securityConfig) {
        console.log('üõ°Ô∏è Gate 3: Audit s√©curit√©...');
        
        try {
            const auditLevel = securityConfig.level === 'critical' ? 'critical' : 
                              securityConfig.level === 'high' ? 'high' : 'moderate';
            
            const result = execSync(`npm audit --audit-level ${auditLevel} --json`, { 
                encoding: 'utf8',
                cwd: this.projectRoot 
            });
            
            const auditData = JSON.parse(result);
            const vulnerabilities = auditData.metadata ? auditData.metadata.vulnerabilities : {};
            
            const criticalCount = vulnerabilities.critical || 0;
            const highCount = vulnerabilities.high || 0;
            const moderateCount = vulnerabilities.moderate || 0;
            
            let passed = true;
            if (securityConfig.level === 'critical') {
                passed = criticalCount === 0 && highCount === 0 && moderateCount === 0;
            } else if (securityConfig.level === 'high') {
                passed = criticalCount === 0 && highCount === 0;
            } else {
                passed = criticalCount === 0;
            }
            
            const status = passed ? '‚úÖ' : '‚ùå';
            console.log(`${status} S√©curit√©: Critical:${criticalCount}, High:${highCount}, Moderate:${moderateCount}`);
            
            this.results.push({
                gate: 'Security Audit',
                status: passed ? 'PASS' : 'FAIL',
                value: `C:${criticalCount} H:${highCount} M:${moderateCount}`,
                threshold: `Level: ${securityConfig.level}`,
                details: passed ? 'Aucune vuln√©rabilit√© bloquante' : `Vuln√©rabilit√©s d√©tect√©es niveau ${securityConfig.level}`
            });
            
            return passed;
            
        } catch (error) {
            // npm audit peut retourner exit code 1 pour warnings
            if (error.status === 1 && error.stdout) {
                try {
                    const auditData = JSON.parse(error.stdout);
                    // Retraiter avec les donn√©es de stdout
                    return this.processSecurityAuditData(auditData, securityConfig);
                } catch (parseError) {
                    console.log('‚ùå Gate 3: Erreur parsing audit s√©curit√©');
                    return false;
                }
            }
            
            console.log('‚ùå Gate 3: √âchec audit s√©curit√©');
            this.results.push({
                gate: 'Security Audit',
                status: 'ERROR',
                value: 'N/A',
                threshold: `Level: ${securityConfig.level}`,
                details: `Erreur audit: ${error.message}`
            });
            return false;
        }
    }

    /**
     * Gate 4: Linting et qualit√© statique
     */
    async gateLinting() {
        console.log('üîç Gate 4: Linting...');
        
        try {
            execSync('npm run lint', { 
                encoding: 'utf8',
                cwd: this.projectRoot,
                stdio: 'pipe'
            });
            
            console.log('‚úÖ Linting: Aucune erreur');
            
            this.results.push({
                gate: 'Linting',
                status: 'PASS',
                value: '0 errors',
                threshold: '0 errors',
                details: 'Code conforme aux standards'
            });
            
            return true;
            
        } catch (error) {
            console.log('‚ùå Linting: Erreurs d√©tect√©es');
            
            this.results.push({
                gate: 'Linting',
                status: 'FAIL',
                value: 'Errors found',
                threshold: '0 errors',
                details: 'Erreurs ESLint/Prettier d√©tect√©es'
            });
            
            return false;
        }
    }

    /**
     * Gate 5: Build
     */
    async gateBuild() {
        console.log('üèóÔ∏è Gate 5: Build...');
        
        try {
            execSync('npm run build', { 
                encoding: 'utf8',
                cwd: this.projectRoot,
                stdio: 'pipe'
            });
            
            console.log('‚úÖ Build: Succ√®s');
            
            this.results.push({
                gate: 'Build',
                status: 'PASS',
                value: 'Success',
                threshold: 'Must compile',
                details: 'Compilation r√©ussie'
            });
            
            return true;
            
        } catch (error) {
            console.log('‚ùå Build: √âchec compilation');
            
            this.results.push({
                gate: 'Build',
                status: 'FAIL',
                value: 'Failed',
                threshold: 'Must compile',
                details: 'Erreurs de compilation d√©tect√©es'
            });
            
            return false;
        }
    }

    /**
     * Gate 6: Performance (optionnel)
     */
    async gatePerformance(performanceConfig) {
        console.log('‚ö° Gate 6: Performance...');
        
        // Pour l'instant, on simule un test de performance basique
        // Dans un vrai projet, utiliser Lighthouse CI ou similaire
        
        console.log('‚ö†Ô∏è Performance: Simulation (Lighthouse CI non configur√©)');
        
        this.results.push({
            gate: 'Performance',
            status: 'SKIP',
            value: 'N/A',
            threshold: `Lighthouse ‚â• ${performanceConfig.lighthouse}`,
            details: 'Lighthouse CI non configur√©'
        });
        
        return true; // Ne pas bloquer pour l'instant
    }

    /**
     * G√©n√©ration rapport d√©taill√©
     */
    generateReport(phase, allPassed) {
        const passedCount = this.results.filter(r => r.status === 'PASS').length;
        const failedCount = this.results.filter(r => r.status === 'FAIL').length;
        const skippedCount = this.results.filter(r => r.status === 'SKIP').length;
        
        const report = `# üìä Quality Gates Report - ${phase}

**Date**: ${new Date().toISOString()}
**Status**: ${allPassed ? '‚úÖ PASS' : '‚ùå FAIL'}
**Score**: ${passedCount}/${this.results.length - skippedCount} gates pass√©es

## üìã D√©tail des Gates

| Gate | Status | Valeur | Seuil | D√©tails |
|------|--------|--------|-------|---------|
${this.results.map(r => `| ${r.gate} | ${r.status} | ${r.value} | ${r.threshold} | ${r.details} |`).join('\n')}

## üìà Statistiques
- ‚úÖ **Pass√©es**: ${passedCount}
- ‚ùå **√âchou√©es**: ${failedCount}
- ‚ö†Ô∏è **Ignor√©es**: ${skippedCount}

## üéØ Actions Recommand√©es
${failedCount > 0 ? this.generateActionRecommendations() : 'üéâ Toutes les quality gates sont pass√©es !'}

---
*G√©n√©r√© par Quality Gates v2.0*
`;

        const reportPath = path.join(this.projectRoot, 'REPORT_QUALITY_GATES.md');
        fs.writeFileSync(reportPath, report, 'utf8');
        
        console.log(`üìã Rapport g√©n√©r√©: ${reportPath}`);
        
        if (allPassed) {
            console.log('üéâ Toutes les Quality Gates sont pass√©es !');
        } else {
            console.log('‚ùå Certaines Quality Gates ont √©chou√©. Voir le rapport pour d√©tails.');
        }
    }

    /**
     * G√©n√©ration recommandations d'actions
     */
    generateActionRecommendations() {
        const failedGates = this.results.filter(r => r.status === 'FAIL');
        
        const recommendations = failedGates.map(gate => {
            switch (gate.gate) {
                case 'Test Coverage':
                    return '- üß™ **Augmenter couverture tests**: Ajouter tests unitaires/int√©gration manquants';
                case 'Code Complexity':
                    return '- üìä **R√©duire complexit√©**: Refactoriser fonctions complexes en sous-fonctions';
                case 'Security Audit':
                    return '- üõ°Ô∏è **Corriger vuln√©rabilit√©s**: `npm audit fix` ou mise √† jour d√©pendances';
                case 'Linting':
                    return '- üîç **Corriger style**: `npm run lint:fix` ou correction manuelle';
                case 'Build':
                    return '- üèóÔ∏è **Corriger compilation**: R√©soudre erreurs TypeScript/syntax';
                default:
                    return `- ‚ö†Ô∏è **${gate.gate}**: ${gate.details}`;
            }
        });
        
        return recommendations.join('\n');
    }

    /**
     * Traitement donn√©es audit s√©curit√©
     */
    processSecurityAuditData(auditData, securityConfig) {
        const vulnerabilities = auditData.metadata ? auditData.metadata.vulnerabilities : {};
        
        const criticalCount = vulnerabilities.critical || 0;
        const highCount = vulnerabilities.high || 0;
        const moderateCount = vulnerabilities.moderate || 0;
        
        let passed = true;
        if (securityConfig.level === 'critical') {
            passed = criticalCount === 0 && highCount === 0 && moderateCount === 0;
        } else if (securityConfig.level === 'high') {
            passed = criticalCount === 0 && highCount === 0;
        } else {
            passed = criticalCount === 0;
        }
        
        const status = passed ? '‚úÖ' : '‚ùå';
        console.log(`${status} S√©curit√©: Critical:${criticalCount}, High:${highCount}, Moderate:${moderateCount}`);
        
        this.results.push({
            gate: 'Security Audit',
            status: passed ? 'PASS' : 'FAIL',
            value: `C:${criticalCount} H:${highCount} M:${moderateCount}`,
            threshold: `Level: ${securityConfig.level}`,
            details: passed ? 'Aucune vuln√©rabilit√© bloquante' : `Vuln√©rabilit√©s d√©tect√©es niveau ${securityConfig.level}`
        });
        
        return passed;
    }
}

// Ex√©cution
if (require.main === module) {
    const qualityGates = new QualityGates();
    const phase = process.argv[2]; // Optionnel: sp√©cifier phase
    
    qualityGates.executeAll(phase)
        .then(success => {
            process.exit(success ? 0 : 1);
        })
        .catch(error => {
            console.error('üí• Erreur Quality Gates:', error);
            process.exit(1);
        });
}

module.exports = QualityGates;
